{"index":{"title":"Fundamentals","links":["programming/cpp/"],"tags":[],"content":"Table of contents §\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTopicSub-topicsProgramming—C++"},"programming/CPP/index":{"title":"C++","links":[],"tags":[],"content":""},"programming/CPP/vars":{"title":"Cplusplus","links":[],"tags":[],"content":"Data types §\nUnlike Python, variables need to be declared along with their respective types before value assignment in C++. In C++, there are several primitive data types available for use. Underneath it all at the lower levels, the only difference between these primitive data types is their size.\nThe actual size of data types depends on what compiler we are using. Typical sizes of the primitive data types are as follows:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nData typeSize (bytes)Notesint4Signed integer in (−231,231). One bit reserved for the sign.short2Small integerslongat least 4Large integersfloat4Stores decimals and exponentialsdouble8Double floating pointchar1ASCII value stored in char variables lying in [0,255].bool1True / False\n\n\n                  \n                  Tip \n                  \n                \nThe “unsigned” keyword allows us to use the bit occupied by the sign, thus doubling our data range.\nunsigned int var = 4;\nstd::cout &lt;&lt; sizeof(var) &lt;&lt; std::endl;\nThe “sizeof” operator can be used to check the size allotted by the C++ compiler to the specific data type.\n\n\n\n                  \n                  Warning \n                  \n                \nThe C++ compiler interprets decimal values as type double. To prevent this and force the use of type float, use a suffix “f” or “F” at the end of a float value.\nNote: Unless this is required, better to use double instead of floats to avoid errors when dealing with large numbers.\nfloat a = 3.4;  //converted to double\n\ndouble b = 3E-6;\nfloat c = 4.5F; // forced float\n\n\n                  \n                  Tip \n                  \n                \nThe bool data type occupies 1 byte of memory despite being 0 or 1 (represented by one bit). This is on account of addressing memory limitations, as we can only access bytes.\n\nFunctions §\nFunctions in C++ help prevent code duplication. All C++ functions require the declaration to begin with a type and indicate the type of value returned by the function. Type definitions are also required by the function arguments. The function arguments can be either passed by value or by reference.\n\n\n                  \n                  Tip \n                  \n                \nThe “main” function is a special case that does not require returning a value.\nThe following program in C++ would work without any errors.\nint main(){\n// code here\n// no return statement\n}\n\nValue §\nint function(int a, int b) {// do something\n}\n \nint x=2, y=3, z;\nz = function(x, y);\nWhen arguments are passed by values, copies of the variables are created and processed by the function without affecting the original variables. In the above example, copies of variables x and y are created when function is called.\nReference §\nint function(int&amp; a, int&amp; b) {// do something\n}\n \nint x=2, y=3, z;\nz = function(x, y);\nWith arguments passed by reference, external variables can be accessed directly within the function. in C++, references are indicated with an ampersand (&amp;) sign. In this case, instead of creating a copy, the variable itself is processed by the function. Any modifications made to the local variable are reflected in the variables passed as arguments.\n\n\n                  \n                  Warning \n                  \n                \nAs the function with arguments by reference accesses the original variables stored in memory, directly passing values as arguments is not allowed. For example, the following code results in a compilation error.\nint func(int&amp; a) { std::cout &lt;&lt; a &lt;&lt; std::endl; }\n\nint main { func(4); }\n\nBut the following works fine:\n```cpp\nint func(int&amp; a) { std::cout &lt;&lt; a &lt;&lt; std::endl; }\n\n\nint var = 4;\nint main { func(var); }\n\nPassing values directly without defining variables only works for functions with arguments passed by values due to their variable copying behavior.\n\n\nEfficiency considerations - For functions with arguments passed by values, creating copies of variable types like int, float, and char is inexpensive. However, creating copies for data types like string can result in a memory overhead. To enable memory-efficient operation, we can replace such functions to use arguments by references with the const keyword.\nstring func(const string&amp; a){\n// do something with string a without modifying\n}\nThe function above behaves like the arguments by values counterpart, such that the original variables remain unmodified but without creating copies."},"programming/cpp_variables":{"title":"Variables & Functions","links":[],"tags":[],"content":"Data types §\nUnlike Python, variables need to be declared along with their respective types before value assignment in C++. In C++, there are several primitive data types available for use. Underneath it all at the lower levels, the only difference between these primitive data types is their size.\nThe actual size of data types depends on what compiler we are using. Typical sizes of the primitive data types are as follows:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nData typeSize (bytes)Notesint4Signed integer in (−231,231). One bit reserved for the sign.short2Small integerslongat least 4Large integersfloat4Stores decimals and exponentialsdouble8Double floating pointchar1ASCII value stored in char variables lying in [0,255].bool1True / False\n\n\n                  \n                  Tip \n                  \n                \nThe “unsigned” keyword allows us to use the bit occupied by the sign, thus doubling our data range.\nunsigned int var = 4;\nstd::cout &lt;&lt; sizeof(var) &lt;&lt; std::endl;\nThe “sizeof” operator can be used to check the size allotted by the C++ compiler to the specific data type.\n\n\n\n                  \n                  Warning \n                  \n                \nThe C++ compiler interprets decimal values as type double. To prevent this and force the use of type float, use a suffix “f” or “F” at the end of a float value.\nNote: Unless this is required, better to use double instead of floats to avoid errors when dealing with large numbers.\nfloat a = 3.4;  //converted to double\n\ndouble b = 3E-6;\nfloat c = 4.5F; // forced float\n\n\n                  \n                  Tip \n                  \n                \nThe bool data type occupies 1 byte of memory despite being 0 or 1 (represented by one bit). This is on account of addressing memory limitations, as we can only access bytes.\n\nFunctions §\nFunctions in C++ help prevent code duplication. All C++ functions require the declaration to begin with a type and indicate the type of value returned by the function. Type definitions are also required by the function arguments. The function arguments can be either passed by value or by reference.\n\n\n                  \n                  Tip \n                  \n                \nThe “main” function is a special case that does not require returning a value.\nThe following program in C++ would work without any errors.\nint main(){\n// code here\n// no return statement\n}\n\nValue §\nint function(int a, int b) {// do something\n}\n \nint x=2, y=3, z;\nz = function(x, y);\nWhen arguments are passed by values, copies of the variables are created and processed by the function without affecting the original variables. In the above example, copies of variables x and y are created when function is called.\nReference §\nint function(int&amp; a, int&amp; b) {// do something\n}\n \nint x=2, y=3, z;\nz = function(x, y);\nWith arguments passed by reference, external variables can be accessed directly within the function. in C++, references are indicated with an ampersand (&amp;) sign. In this case, instead of creating a copy, the variable itself is processed by the function. Any modifications made to the local variable are reflected in the variables passed as arguments.\n\n\n                  \n                  Warning \n                  \n                \nAs the function with arguments by reference accesses the original variables stored in memory, directly passing values as arguments is not allowed. For example, the following code results in a compilation error.\nint func(int&amp; a) { std::cout &lt;&lt; a &lt;&lt; std::endl; }\n\nint main { func(4); }\n\nBut the following works fine:\n```cpp\nint func(int&amp; a) { std::cout &lt;&lt; a &lt;&lt; std::endl; }\n\n\nint var = 4;\nint main { func(var); }\n\nPassing values directly without defining variables only works for functions with arguments passed by values due to their variable copying behavior.\n\n\nEfficiency considerations - For functions with arguments passed by values, creating copies of variable types like int, float, and char is inexpensive. However, creating copies for data types like string can result in a memory overhead. To enable memory-efficient operation, we can replace such functions to use arguments by references with the const keyword.\nstring func(const string&amp; a){\n// do something with string a without modifying\n}\nThe function above behaves like the arguments by values counterpart, such that the original variables remain unmodified but without creating copies."},"programming/index":{"title":"Programming","links":[],"tags":[],"content":""},"programming/test":{"title":"Test","links":[],"tags":[],"content":""}}