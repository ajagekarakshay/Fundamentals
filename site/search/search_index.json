{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Fundamentals","text":""},{"location":"#table-of-contents","title":"Table of contents","text":"Topic Sub-topics Programming C++ Math Stochastic Calculus <p>Info</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p>"},{"location":"math/distrib/","title":"Distributions","text":""},{"location":"math/distrib/#discrete-distributions","title":"Discrete distributions","text":"<p>A random variable \\(X\\) is discrete if \\(\\sum_{x\\in R}P(X=x)=1\\).</p>"},{"location":"math/distrib/#1-degenerate","title":"1. Degenerate","text":""},{"location":"math/distrib/#2-bernoulli","title":"2. Bernoulli","text":""},{"location":"math/distrib/#3-binomial","title":"3. Binomial","text":""},{"location":"math/distrib/#4-geometric","title":"4. Geometric","text":""},{"location":"math/distrib/#5-negative-binomial","title":"5. Negative-Binomial","text":""},{"location":"math/distrib/#6-poisson","title":"6. Poisson","text":""},{"location":"math/distrib/#continuous-distributions","title":"Continuous distributions","text":""},{"location":"math/distrib/#1-uniform","title":"1. Uniform","text":""},{"location":"math/distrib/#2-exponential","title":"2. Exponential","text":""},{"location":"math/distrib/#3-gamma","title":"3. Gamma","text":""},{"location":"math/distrib/#4-normal-gaussian","title":"4. Normal / Gaussian","text":""},{"location":"math/series/","title":"Mathematical series","text":""},{"location":"math/series/#finite-series","title":"Finite series","text":""},{"location":"math/series/#1-powers","title":"1. Powers","text":"<p>\\[ \\sum_{x=1}^{n}x=\\frac{n(n+1)}{2} \\] \\[ \\sum_{x=1}^{n}x^2=\\frac{n(n+1)(2n+1)}{6} \\] \\[ \\sum_{x=1}^{n}x^3=\\frac{n^2(n+1)^2}{2^2} \\]</p>"},{"location":"math/series/#2-binomial-coefficients","title":"2. Binomial coefficients","text":"<p>\\[ \\sum_{k=0}^{n}{}^nC_k=2^n \\]</p> <p>\\[ \\sum_{k=0}^{n}{^{}{}^nC_k}^2={}^{2n}C_n \\]</p>"},{"location":"math/series/#infinite-series","title":"Infinite series","text":"<p>[!warning] Infinite sums for smooth exponential, trigonometric, and binomial functions are valid only for \\(|x|&lt;1\\).</p>"},{"location":"math/series/#1-exponential-and-logarithmic","title":"1. Exponential and Logarithmic","text":"<p>\\[ e^x=1+x+\\frac{x^2}{2!}+...=\\sum_{k=1}^{\\infty}\\frac{x^k}{k!} \\] \\[ ln(1+x)=x-\\frac{x^2}{2}+\\frac{x^3}{3}-... \\] \\[ \\sum_{k=0}^{\\infty}\\frac{1}{(2k+1)(2k+2)}=\\frac{1}{2\\times3}+\\frac{1}{4\\times5}+...=ln2 \\] \\[ \\sum_{k=0}^{\\infty}\\frac{1}{2^{k}k}=ln2 \\]</p>"},{"location":"math/series/#2-trigonometric","title":"2. Trigonometric","text":"<p>\\[ sin(x)=x-\\frac{x^3}{3!}+\\frac{x^5}{5!}+... \\] \\[ sinh(x)=x+\\frac{x^3}{3!}+\\frac{x^5}{5!}+... \\]</p>"},{"location":"math/series/#3-binomial","title":"3. Binomial","text":"<p>\\[ (1+x)^{\\alpha}=\\sum_{k=0}^{\\infty}{}^{\\alpha}C_k{\\cdot}{x^k} \\] \\[ (1-x)^{-\\alpha}=\\sum_{k=0}^{\\infty}{}^{\\alpha+k-1}C_k{\\cdot}{x^k} \\]</p>"},{"location":"math/series/#4-riemann-zeta-function","title":"4. Riemann zeta function","text":"<p>\\[ \\sum_{k=1}^{\\infty}\\frac{1}{k^2}=\\zeta(2)=\\frac{\\pi^2}{6} \\] \\[ \\sum_{k=1}^{\\infty}\\frac{1}{k^4}=\\zeta(4)=\\frac{\\pi^4}{45} \\] \\[ \\sum_{k=1}^{\\infty}\\frac{1}{k^6}=\\zeta(2)=\\frac{\\pi^6}{945} \\]</p>"},{"location":"math/series/#5-alternating-harmonic","title":"5. Alternating harmonic","text":"<p>From series \\(ln(1+x)\\): \\[  1-\\frac{1}{2}+\\frac{1}{3}-\\frac{1}{4}+...=ln(2) \\] \\[ 1-\\frac{1}{3}+\\frac{1}{5}-\\frac{1}{7}+...=\\frac{\\pi}{4} \\]</p>"},{"location":"math/series/#6-reciprocal-of-factorials","title":"6. Reciprocal of factorials","text":"<p>Can be derived from [[series#1. Exponential and Logarithmic|Exponential series]]: \\[ 1+\\frac{1}{1!}+\\frac{1}{2!}+\\frac{1}{3!}+...=e \\] \\[ \\frac{1}{0!}+\\frac{1}{2!}+\\frac{1}{4!}+\\frac{1}{6!}+...=\\frac{1}{2}(e+\\frac{1}{e})=cosh(1) \\]</p>"},{"location":"math/calc/codes/","title":"%% section name %%","text":"<pre><code>print(\"Hello world\")\n</code></pre>"},{"location":"programming/CPP/vars/","title":"Variables and Functions","text":""},{"location":"programming/CPP/vars/#data-types","title":"Data types","text":"<p>Unlike Python, variables need to be declared along with their respective types before value assignment in C++. In C++, there are several primitive data types available for use. Underneath it all at the lower levels, the only difference between these primitive data types is their size.</p> <p>The actual size of data types depends on what compiler we are using. Typical sizes of the primitive data types are as follows:</p> Data type Size (bytes) Notes int 4 Signed integer in \\((-2^{31}, 2^{31})\\). One bit reserved for the sign. short 2 Small integers long at least 4 Large integers float 4 Stores decimals and exponentials double 8 Double floating point char 1 ASCII value stored in char variables lying in \\([0,255]\\). bool 1 True / False <p>[!hint]  The \"unsigned\" keyword allows us to use the bit occupied by the sign, thus doubling our data range.</p> <p><pre><code>unsigned int var = 4;\nstd::cout &lt;&lt; sizeof(var) &lt;&lt; std::endl;\n</code></pre> The \"sizeof\" operator can be used to check the size allotted by the C++ compiler to the specific data type.</p> <p>[!warning]  The C++ compiler interprets decimal values as type double. To prevent this and force the use of type float, use a suffix \"f\" or \"F\" at the end of a float value. Note: Unless this is required, better to use double instead of floats to avoid errors when dealing with large numbers. ```cpp float a = 3.4;  //converted to double double b = 3E-6; float c = 4.5F; // forced float</p> <p>[!hint] The bool data type occupies 1 byte of memory despite being 0 or 1 (represented by one bit). This is on account of addressing memory limitations, as we can only access bytes.</p>"},{"location":"programming/CPP/vars/#functions","title":"Functions","text":"<p>Functions in C++ help prevent code duplication. All C++ functions require the declaration to begin with a type and indicate the type of value returned by the function. Type definitions are also required by the function arguments. The function arguments can be either passed by value or by reference.</p> <p>[!hint] The \"main\" function is a special case that does not require returning a value. The following program in C++ would work without any errors. <pre><code>int main(){\n// code here\n// no return statement\n}\n</code></pre></p>"},{"location":"programming/CPP/vars/#value","title":"Value","text":"<p><pre><code>int function(int a, int b) {// do something\n}\n\nint x=2, y=3, z;\nz = function(x, y);\n</code></pre> When arguments are passed by values, copies of the variables are created and processed by the function without affecting the original variables. In the above example, copies of variables x and y are created when function is called.</p>"},{"location":"programming/CPP/vars/#reference","title":"Reference","text":"<p><pre><code>int function(int&amp; a, int&amp; b) {// do something\n}\n\nint x=2, y=3, z;\nz = function(x, y);\n</code></pre> With arguments passed by reference, external variables can be accessed directly within the function. in C++, references are indicated with an ampersand (&amp;) sign. In this case, instead of creating a copy, the variable itself is processed by the function. Any modifications made to the local variable are reflected in the variables passed as arguments.</p> <p>[!warning] As the function with arguments by reference accesses the original variables stored in memory, directly passing values as arguments is not allowed. For example, the following code results in a compilation error. <code>cpp int func(int&amp; a) { std::cout &lt;&lt; a &lt;&lt; std::endl; } int main { func(4); }</code> But the following works fine: <code>cpp int func(int&amp; a) { std::cout &lt;&lt; a &lt;&lt; std::endl; } int var = 4; int main { func(var); }</code> Passing values directly without defining variables only works for functions with arguments passed by values due to their variable copying behavior.</p> <p>Efficiency considerations - For functions with arguments passed by values, creating copies of variable types like int, float, and char is inexpensive. However, creating copies for data types like string can result in a memory overhead. To enable memory-efficient operation, we can replace such functions to use arguments by references with the const keyword.</p> <p><pre><code>string func(const string&amp; a){\n// do something with string a without modifying\n}\n</code></pre> The function above behaves like the arguments by values counterpart, such that the original variables remain unmodified but without creating copies.</p>"}]}